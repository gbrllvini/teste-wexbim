export declare const fragment_shader = "precision highp float;\n\nuniform vec4 uClippingPlaneA;\nuniform vec4 uClippingPlaneB;\nuniform bool uClippingA;\nuniform bool uClippingB;\n\n\nuniform vec3 uGBC;\n\n\nuniform vec3 uLight;\n\n\nuniform mat4 uSectionBox;\n\nvarying vec4 vColor;\n\nvarying vec3 vPosition;\n\nvarying vec3 vNormal;\n\n\nvarying float vDiscard;\n\nvoid main(void) {\n \n if ( vDiscard > 0.5) discard;\n \n \n vec4 fp = uSectionBox * vec4(vPosition, 1);\n if (\n fp.x > 1.0 || fp.x < -1.0 || \n fp.y > 1.0 || fp.y < -1.0 || \n fp.z > 1.0 || fp.z < -1.0) \n discard;\n\n \n if (uClippingA)\n {\n \n vec4 p = uClippingPlaneA;\n vec3 x = vPosition;\n float distance = (dot(p.xyz, x) + p.w) / length(p.xyz);\n if (distance < 0.0){\n discard;\n return;\n }\n }\n\n \n if (uClippingB)\n {\n \n vec4 p = uClippingPlaneB;\n vec3 x = vPosition;\n float distance = (dot(p.xyz, x) + p.w) / length(p.xyz);\n if (distance < 0.0) {\n discard;\n return;\n }\n }\n \n \n if (length(vNormal) < 0.1) {\n gl_FragColor = vColor;\n return;\n }\n\n \n vec3 normalInterp = gl_FrontFacing ? vNormal : -vNormal;\n\n \n float Ka = 1.0; \n float Kd = 1.0; \n float Ks = 0.2; \n float shininessVal = 30.0; \n\n vec3 ambientColor = vColor.rgb * 0.2; \n vec3 diffuseColor = vColor.rgb;\n vec3 specularColor = vec3(1.0, 1.0, 1.0);\n\n vec3 N = normalize(normalInterp);\n vec3 L = normalize(uLight - vPosition);\n\n \n float lambertian = max(dot(N, L), 0.0);\n\n float specular = 0.0;\n\n if(lambertian > 0.0) {\n vec3 R = reflect(-L, N); \n \n vec3 V = L; \n\n \n float specAngle = max(dot(R, V), 0.0);\n specular = pow(specAngle, shininessVal);\n }\n\n vec4 fragColor = vec4(\n Ka * ambientColor +\n Kd * lambertian * diffuseColor +\n Ks * specular * specularColor\n , vColor.a\n );\n\n \n \n fragColor.r = (pow(fragColor.r,uGBC[0]) - 0.5)*uGBC[1] + uGBC[2] + 0.5;\n fragColor.g = (pow(fragColor.g,uGBC[0]) - 0.5)*uGBC[1] + uGBC[2] + 0.5;\n fragColor.b = (pow(fragColor.b,uGBC[0]) - 0.5)*uGBC[1] + uGBC[2] + 0.5;\n\n gl_FragColor = fragColor;\n}";
